const express = require('express');
const router = express.Router();
const { ScheduledLesson, Section, TextbookEntry, AdminScheduleEntry } = require('../models');
const { Op } = require('sequelize');

// Helpers
const toArray = (val) => {
  if (!val) return [];
  if (Array.isArray(val)) return val;
  if (typeof val === 'string') {
    try { return JSON.parse(val); } catch { return []; }
  }
  return [];
};

const toStagesArray = (val) => {
  if (!val) return [];
  if (Array.isArray(val)) return val;
  if (typeof val === 'string') {
    try { return JSON.parse(val); } catch { return []; }
  }
  return [];
};

const getCompletedStages = (stages) =>
  stages.filter((st) => st && (st.isCompleted === true || st.isCompleted === 'true' || st.isCompleted === 1 || st.isCompleted === '1'));

// Day helpers (English names to match schedule.csv/AdminSchedule)
function getDayNameFromDate(dateStr) {
  try {
    // Robust parsing of YYYY-MM-DD to avoid TZ issues
    const [y, m, d] = String(dateStr).split('-').map((v) => parseInt(v, 10));
    if (!y || !m || !d) return null;
    const date = new Date(y, m - 1, d); // local date
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    return days[date.getDay()];
  } catch {
    return null;
  }
}

function mapEnglishToArabicDay(dayEn) {
  const DAY_MAP = {
    'Monday': 'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†',
    'Tuesday': 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡',
    'Wednesday': 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡',
    'Thursday': 'Ø§Ù„Ø®Ù…ÙŠØ³',
    'Friday': 'Ø§Ù„Ø¬Ù…Ø¹Ø©',
    'Saturday': 'Ø§Ù„Ø³Ø¨Øª',
    'Sunday': 'Ø§Ù„Ø£Ø­Ø¯'
  };
  return DAY_MAP[dayEn] || dayEn;
}

async function pickScheduleFor(sectionId, dateStr, sessionNumber) {
  try {
    const dayNameEn = getDayNameFromDate(dateStr);
    const dayNameAr = mapEnglishToArabicDay(dayNameEn);
    if (!dayNameEn) return null;
    const entries = await AdminScheduleEntry.findAll({
      where: { sectionId: String(sectionId), day: dayNameAr },
      order: [['startTime', 'ASC']],
    });
    if (!entries || entries.length === 0) {
      console.warn(`[schedule-pick] No entries for section=${sectionId} day=${dayNameAr} (from ${dayNameEn})`);
      return null;
    }
    const idxBase = (Number(sessionNumber) || 1) - 1;
    const idx = Math.max(0, Math.min(entries.length - 1, idxBase));
    const picked = entries[idx];
    console.log(`[schedule-pick] Picked time ${picked.startTime} for section=${sectionId} day=${dayNameAr} session=${sessionNumber} idx=${idx}/${entries.length}`);
    return picked;
  } catch {
    return null;
  }
}

function computeEndTime(startTime, durationHours) {
  try {
    if (!startTime) return null;
    const [hh, mm] = String(startTime).split(':').map((v) => parseInt(v, 10));
    if (Number.isNaN(hh) || Number.isNaN(mm)) return null;
    const minsToAdd = Math.round(Number(durationHours || 1) * 60);
    let totalMins = hh * 60 + mm + minsToAdd;
    totalMins = ((totalMins % (24 * 60)) + (24 * 60)) % (24 * 60); // wrap 24h
    const eh = Math.floor(totalMins / 60);
    const em = totalMins % 60;
    const pad = (n) => String(n).padStart(2, '0');
    return `${pad(eh)}:${pad(em)}`;
  } catch {
    return null;
  }
}

async function upsertTextbookEntriesForLesson(lesson) {
  try {
    const assigned = toArray(lesson.assignedSections).map(String);
    const stagesArr = toStagesArray(lesson.stages);
    const completedStages = getCompletedStages(stagesArr);

    // If no assigned sections or no completed stages, delete existing entries for this lesson
    if (!assigned.length || !completedStages.length) {
      await TextbookEntry.destroy({ where: { originalLessonId: String(lesson.id) } });
      return { updated: 0, deleted: 1 };
    }

    let updated = 0;
    for (const secId of assigned) {
      let secName = String(secId);
      try {
        const sec = await Section.findByPk(String(secId));
        if (sec) secName = sec.name;
      } catch {}

      const entryId = `${lesson.id}_${secId}`;
      const lessonTitle = lesson.customTitle || lesson.subject || '';
      const lessonContent = completedStages
        .map((stage, idx) => `âœ“ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${idx + 1}: ${stage.title || stage.name || `Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${idx + 1}`}`)
        .join('\n');

      // Determine accurate time from AdminSchedule if available
      const picked = await pickScheduleFor(secId, lesson.date, lesson.manualSessionNumber);
      const computedStartTime = picked?.startTime || lesson.startTime || '08:00';
      const computedDuration = picked?.duration != null ? Number(picked.duration) : 1.0;

      const payload = {
        id: entryId,
        date: lesson.date,
        startTime: computedStartTime,
        duration: computedDuration,
        sectionId: String(secId),
        sectionName: secName,
        lessonTitle: lessonTitle || 'Ø­ØµØ© Ø¯Ø±Ø§Ø³ÙŠØ©',
        sessionNumber: lesson.manualSessionNumber || 1,
        completedStages: completedStages,
        lessonContent,
        isAutoGenerated: true,
        originalLessonId: String(lesson.id),
      };

      const existing = await TextbookEntry.findByPk(entryId);
      if (existing) await existing.update(payload);
      else await TextbookEntry.create(payload);
      updated += 1;
    }
    return { updated, deleted: 0 };
  } catch (e) {
    console.warn('[textbook] upsert helper failed:', e?.message || e);
    return { updated: 0, deleted: 0, error: e?.message || String(e) };
  }
}

// GET all scheduled lessons
router.get('/', async (req, res) => {
  try {
    console.log('ðŸ“‹ [ScheduledLessons] GET request received');
    const lessons = await ScheduledLesson.findAll();
    console.log(`âœ… [ScheduledLessons] Found ${lessons.length} lessons`);
    res.json(lessons);
  } catch (error) {
    console.error('âŒ [ScheduledLessons] GET error:', error);
    res.status(500).json({ error: error.message, stack: error.stack });
  }
});

// GET textbook data from scheduled lessons
router.get('/textbook', async (req, res) => {
  try {
    const { sectionId, level, dateFrom, dateTo } = req.query;

    let where = {};
    
    // Filter by section
    if (sectionId && sectionId !== 'all') {
      where.sectionId = sectionId;
    }
    
    // Filter by educational level
    if (level && level !== 'all') {
      // Get sections that match the educational level
      const sectionsForLevel = await Section.findAll({
        where: { educationalLevel: level },
        attributes: ['id']
      });
      const sectionIds = sectionsForLevel.map(s => s.id);
      
      if (sectionIds.length > 0) {
        if (where.sectionId) {
          // If section is already filtered, ensure it's in the level filter
          if (!sectionIds.includes(where.sectionId)) {
            return res.json([]); // No results if section doesn't match level
          }
        } else {
          // Apply level filter
          where.sectionId = { [Op.in]: sectionIds };
        }
      } else {
        return res.json([]); // No sections for this level
      }
    }

    // Date range filter
    if (dateFrom || dateTo) {
      where.date = {};
      if (dateFrom) where.date[Op.gte] = dateFrom;
      if (dateTo) where.date[Op.lte] = dateTo;
    }

    const entries = await TextbookEntry.findAll({
      where,
      order: [['date', 'DESC'], ['startTime', 'ASC']],
    });

    // Ensure startTime aligns with AdminSchedule when possible (display-level correction)
    const mapped = await Promise.all(entries.map(async (e) => {
      const completedStages = Array.isArray(e.completedStages) ? e.completedStages : [];
      const subjectDetails = e.lessonTitle
        ? `${e.lessonTitle}:\n${completedStages.map((st, i) => `âœ“ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${i + 1}: ${st.title || st.name || `Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${i + 1}`}`).join('\n')}`
        : completedStages.map((st, i) => `âœ“ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${i + 1}: ${st.title || st.name || `Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${i + 1}`}`).join('\n');

      let startTime = e.startTime;
      let duration = e.duration != null ? Number(e.duration) : 1;
      try {
        const picked = await pickScheduleFor(e.sectionId, e.date, e.sessionNumber || 1);
        if (picked?.startTime) startTime = picked.startTime;
        if (picked?.duration != null) duration = Number(picked.duration);
      } catch {}
      const endTime = computeEndTime(startTime, duration);

      return {
        id: e.id,
        date: e.date,
        startTime,
        endTime,
        duration,
        sectionId: e.sectionId,
        sectionName: e.sectionName,
        lessonNumber: e.sessionNumber || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
        subjectDetails,
        teacherSignature: e.teacherSignature || '',
        completedStagesCount: completedStages.length,
        totalStages: completedStages.length, // Ù„Ø§ Ù†Ù…Ù„Ùƒ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙ„ÙŠ Ù‡Ù†Ø§ØŒ Ù†Ø¹Ø±Ø¶ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù†Ø¬Ø²Ø© ÙÙ‚Ø·
      };
    }));

    res.json(mapped);
  } catch (error) {
    console.error('Error fetching textbook data:', error);
    res.status(500).json({ message: 'Failed to fetch textbook data', error: error.message });
  }
});

// DELETE all scheduled lessons (place before parameterized route to avoid conflicts)
router.delete('/all', async (req, res) => {
  try {
    await ScheduledLesson.destroy({ truncate: true });
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// POST a new scheduled lesson
router.post('/', async (req, res) => {
  try {
    console.log('ðŸ“ [ScheduledLessons] POST request received:', req.body);
    const payload = { ...req.body };
    if (!payload.id) {
      payload.id = Date.now().toString();
    }
    console.log('ðŸ“ [ScheduledLessons] Creating with payload:', payload);
    const lesson = await ScheduledLesson.create(payload);
    console.log('âœ… [ScheduledLessons] Created lesson:', lesson.toJSON());
    // attempt upsert textbook entries for this new lesson (in case it already has completed stages)
    await upsertTextbookEntriesForLesson(lesson);
    res.status(201).json(lesson);
  } catch (error) {
    console.error('âŒ [ScheduledLessons] POST error:', error);
    res.status(400).json({ error: error.message, stack: error.stack });
  }
});

// PUT update a scheduled lesson
router.put('/:id', async (req, res) => {
  try {
    console.log('ðŸ”§ [Backend] PUT /scheduled-lessons/:id - Request Body:', req.body); // ADD THIS LINE
    const lesson = await ScheduledLesson.findByPk(req.params.id);
    if (!lesson) return res.status(404).json({ error: 'Scheduled lesson not found' });
    await lesson.update(req.body);

    // Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ø¯ÙŠØ«: Ø­Ø¯Ù‘Ø«/Ø£Ù†Ø´Ø¦ Ø¥Ø¯Ø®Ø§Ù„Ø§Øª Ø¯ÙØªØ± Ø§Ù„Ù†ØµÙˆØµ
    await upsertTextbookEntriesForLesson(lesson);

    res.json(lesson);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// DELETE a scheduled lesson
router.delete('/:id', async (req, res) => {
  try {
    const lesson = await ScheduledLesson.findByPk(req.params.id);
    if (!lesson) return res.status(404).json({ error: 'Scheduled lesson not found' });
    // Clean up related textbook entries
    await TextbookEntry.destroy({ where: { originalLessonId: String(lesson.id) } });
    await lesson.destroy();
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Generate/Backfill textbook entries from all scheduled lessons
router.post('/textbook/backfill', async (req, res) => {
  try {
    const lessons = await ScheduledLesson.findAll();
    let updated = 0, deleted = 0;
    for (const l of lessons) {
      const result = await upsertTextbookEntriesForLesson(l);
      updated += result.updated || 0;
      deleted += result.deleted || 0;
    }
    res.json({ message: 'Backfill completed', updated, deleted, totalLessons: lessons.length });
  } catch (e) {
    console.error('Backfill failed:', e);
    res.status(500).json({ message: 'Backfill failed', error: e?.message || String(e) });
  }
});

module.exports = router;
