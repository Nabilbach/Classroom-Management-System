/**
 * نظام الحماية الشامل ضد فقدان البيانات
 * Comprehensive Data Protection System
 * 
 * يشمل:
 * 1. استعادة البيانات المفقودة
 * 2. إضافة آليات الحماية (Triggers)
 * 3. نظام مراقبة دوري
 * 4. نسخ احتياطية ذكية
 */

const sqlite3 = require('sqlite3').verbose();
const fs = require('fs');
const path = require('path');

class ComprehensiveDataProtectionSystem {
    constructor(dbPath = 'classroom.db', backupPath = 'classroom_backup_20250924_174347.db') {
        this.dbPath = dbPath;
        this.backupPath = backupPath;
        this.db = null;
        this.backupDb = null;
    }

    async connect() {
        return new Promise((resolve, reject) => {
            this.db = new sqlite3.Database(this.dbPath, sqlite3.OPEN_READWRITE, (err) => {
                if (err) {
                    reject(err);
                } else {
                    console.log('✅ متصل بقاعدة البيانات الحالية');
                    
                    this.backupDb = new sqlite3.Database(this.backupPath, sqlite3.OPEN_READONLY, (err) => {
                        if (err) {
                            console.warn('⚠️ لا يمكن الاتصال بالنسخة الاحتياطية:', err.message);
                            resolve();
                        } else {
                            console.log('✅ متصل بالنسخة الاحتياطية');
                            resolve();
                        }
                    });
                }
            });
        });
    }

    // خطوة 1: استعادة البيانات المفقودة
    async restoreMissingData() {
        console.log('\n🔧 بدء استعادة البيانات المفقودة...');
        
        if (!this.backupDb) {
            console.log('❌ لا توجد نسخة احتياطية متاحة للاستعادة');
            return;
        }

        let restoredCount = 0;

        // استعادة TextbookEntry المفقود
        try {
            console.log('📖 استعادة إدخال دفتر النصوص المفقود...');
            
            // الحصول على الإدخال المفقود
            const missingTextbook = await this.queryBackup(`
                SELECT * FROM TextbookEntries 
                WHERE id NOT IN (
                    SELECT id FROM TextbookEntries
                )
                LIMIT 1
            `);

            if (missingTextbook.length > 0) {
                const entry = missingTextbook[0];
                await this.runQuery(`
                    INSERT INTO TextbookEntries (
                        id, date, startTime, duration, sectionId, sectionName,
                        lessonTitle, sessionNumber, completedStages, lessonContent,
                        teacherSignature, notes, isAutoGenerated, originalLessonId,
                        createdAt, updatedAt
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `, Object.values(entry));
                
                console.log(`   ✅ تم استعادة: ${entry.lessonTitle} - ${entry.date}`);
                restoredCount++;
            }
        } catch (error) {
            console.error('❌ خطأ في استعادة دفتر النصوص:', error.message);
        }

        // استعادة الطالب المفقود
        try {
            console.log('👥 استعادة الطالب المفقود...');
            
            const missingStudent = await this.queryBackup(`
                SELECT * FROM Students 
                ORDER BY id DESC LIMIT 1
            `);

            // تحقق من وجود الطالب في قاعدة البيانات الحالية
            if (missingStudent.length > 0) {
                const student = missingStudent[0];
                const exists = await this.runQuery(`SELECT id FROM Students WHERE id = ?`, [student.id]);
                
                if (exists.length === 0) {
                    await this.runQuery(`
                        INSERT INTO Students (
                            id, first_name, last_name, pathway_number, birth_date,
                            class_order, gender, section_id, createdAt, updatedAt
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    `, Object.values(student));
                    
                    console.log(`   ✅ تم استعادة: ${student.first_name} ${student.last_name}`);
                    restoredCount++;
                }
            }
        } catch (error) {
            console.error('❌ خطأ في استعادة الطالب:', error.message);
        }

        console.log(`\n📊 إجمالي البيانات المستعادة: ${restoredCount}`);
    }

    // خطوة 2: إضافة آليات الحماية (Database Triggers)
    async addProtectionTriggers() {
        console.log('\n🛡️ إضافة آليات الحماية (Triggers)...');
        
        const triggers = [
            // Trigger لتسجيل جميع عمليات الحذف
            {
                name: 'audit_deletions',
                sql: `
                CREATE TRIGGER IF NOT EXISTS audit_deletions_textbook
                BEFORE DELETE ON TextbookEntries
                BEGIN
                    INSERT INTO audit_log (
                        table_name, record_id, action_type, old_values, timestamp
                    ) VALUES (
                        'TextbookEntries',
                        OLD.id,
                        'DELETE',
                        json_object(
                            'id', OLD.id,
                            'date', OLD.date,
                            'lessonTitle', OLD.lessonTitle,
                            'sectionId', OLD.sectionId
                        ),
                        datetime('now')
                    );
                END
                `
            },
            
            // Trigger لحماية الطلاب من الحذف العرضي
            {
                name: 'protect_students',
                sql: `
                CREATE TRIGGER IF NOT EXISTS audit_deletions_students
                BEFORE DELETE ON Students
                BEGIN
                    INSERT INTO audit_log (
                        table_name, record_id, action_type, old_values, timestamp
                    ) VALUES (
                        'Students',
                        OLD.id,
                        'DELETE',
                        json_object(
                            'id', OLD.id,
                            'first_name', OLD.first_name,
                            'last_name', OLD.last_name,
                            'pathway_number', OLD.pathway_number
                        ),
                        datetime('now')
                    );
                END
                `
            },

            // Trigger للنسخ الاحتياطية التلقائية عند التعديلات المهمة
            {
                name: 'backup_on_critical_changes',
                sql: `
                CREATE TRIGGER IF NOT EXISTS backup_on_critical_updates
                AFTER UPDATE ON TextbookEntries
                WHEN OLD.lessonContent != NEW.lessonContent OR OLD.date != NEW.date
                BEGIN
                    INSERT INTO audit_log (
                        table_name, record_id, action_type, old_values, new_values, timestamp
                    ) VALUES (
                        'TextbookEntries',
                        NEW.id,
                        'CRITICAL_UPDATE',
                        json_object('lessonContent', OLD.lessonContent, 'date', OLD.date),
                        json_object('lessonContent', NEW.lessonContent, 'date', NEW.date),
                        datetime('now')
                    );
                END
                `
            }
        ];

        // إنشاء جدول audit_log أولاً
        await this.createAuditLogTable();

        for (const trigger of triggers) {
            try {
                await this.runQuery(trigger.sql);
                console.log(`   ✅ تم إنشاء: ${trigger.name}`);
            } catch (error) {
                console.error(`   ❌ خطأ في ${trigger.name}:`, error.message);
            }
        }
    }

    // إنشاء جدول audit_log
    async createAuditLogTable() {
        const sql = `
        CREATE TABLE IF NOT EXISTS audit_log (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            table_name TEXT NOT NULL,
            record_id TEXT,
            action_type TEXT NOT NULL,
            old_values TEXT,
            new_values TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            user_info TEXT DEFAULT 'system'
        )
        `;
        
        await this.runQuery(sql);
        console.log('   ✅ جدول audit_log جاهز');
    }

    // خطوة 3: نظام المراقبة الدوري
    async createMonitoringSystem() {
        console.log('\n📊 إنشاء نظام المراقبة الدوري...');
        
        const monitoringScript = `
        // نظام المراقبة الدوري - يتم تشغيله كل ساعة
        const sqlite3 = require('sqlite3').verbose();
        
        class DataIntegrityMonitor {
            async checkSystemHealth() {
                const db = new sqlite3.Database('classroom.db');
                
                // فحص التطابق
                const issues = [];
                
                // فحص فقدان البيانات الحديثة
                db.all(\`
                    SELECT COUNT(*) as recent_deletions 
                    FROM audit_log 
                    WHERE action_type = 'DELETE' 
                    AND timestamp >= datetime('now', '-1 hour')
                \`, (err, result) => {
                    if (!err && result[0].recent_deletions > 0) {
                        console.warn('⚠️ تم حذف', result[0].recent_deletions, 'سجل في الساعة الماضية');
                    }
                });
                
                db.close();
            }
        }
        
        // تشغيل الفحص
        setInterval(async () => {
            const monitor = new DataIntegrityMonitor();
            await monitor.checkSystemHealth();
        }, 60 * 60 * 1000); // كل ساعة
        `;
        
        fs.writeFileSync('monitoring_service.js', monitoringScript);
        console.log('   ✅ تم إنشاء ملف المراقبة: monitoring_service.js');
    }

    // خطوة 4: نسخ احتياطية ذكية
    async setupSmartBackups() {
        console.log('\n💾 إعداد النسخ الاحتياطية الذكية...');
        
        const backupScript = `
        const fs = require('fs');
        const path = require('path');
        
        class SmartBackupSystem {
            createBackup() {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const backupName = \`auto_backup_\${timestamp}.db\`;
                
                try {
                    if (!fs.existsSync('auto_backups')) {
                        fs.mkdirSync('auto_backups');
                    }
                    
                    fs.copyFileSync('classroom.db', path.join('auto_backups', backupName));
                    console.log('✅ نسخة احتياطية تلقائية:', backupName);
                    
                    // حذف النسخ القديمة (الاحتفاظ بـ 10 نسخ فقط)
                    this.cleanOldBackups();
                } catch (error) {
                    console.error('❌ خطأ في النسخة الاحتياطية:', error.message);
                }
            }
            
            cleanOldBackups() {
                try {
                    const backupDir = 'auto_backups';
                    const files = fs.readdirSync(backupDir)
                        .filter(file => file.startsWith('auto_backup_'))
                        .map(file => ({
                            name: file,
                            time: fs.statSync(path.join(backupDir, file)).mtime
                        }))
                        .sort((a, b) => b.time - a.time);
                    
                    // حذف النسخ الزائدة
                    files.slice(10).forEach(file => {
                        fs.unlinkSync(path.join(backupDir, file.name));
                        console.log('🗑️ حذف نسخة قديمة:', file.name);
                    });
                } catch (error) {
                    console.error('⚠️ خطأ في تنظيف النسخ القديمة:', error.message);
                }
            }
        }
        
        // نسخة احتياطية كل 6 ساعات
        setInterval(() => {
            const backup = new SmartBackupSystem();
            backup.createBackup();
        }, 6 * 60 * 60 * 1000);
        
        // نسخة احتياطية فورية عند بدء التشغيل
        const initialBackup = new SmartBackupSystem();
        initialBackup.createBackup();
        `;
        
        fs.writeFileSync('smart_backup_service.js', backupScript);
        console.log('   ✅ تم إنشاء ملف النسخ الاحتياطية: smart_backup_service.js');
    }

    // تشغيل النظام الشامل
    async implementFullProtection() {
        console.log('🚨 تطبيق نظام الحماية الشامل ضد فقدان البيانات');
        console.log('='.repeat(80));
        
        try {
            await this.connect();
            
            // خطوة 1: استعادة البيانات المفقودة
            await this.restoreMissingData();
            
            // خطوة 2: إضافة آليات الحماية
            await this.addProtectionTriggers();
            
            // خطوة 3: نظام المراقبة
            await this.createMonitoringSystem();
            
            // خطوة 4: النسخ الاحتياطية الذكية
            await this.setupSmartBackups();
            
            console.log('\n' + '='.repeat(80));
            console.log('✅ تم تطبيق نظام الحماية الشامل بنجاح!');
            console.log('🛡️ النظام محمي الآن ضد:');
            console.log('   • فقدان البيانات العرضي');
            console.log('   • عمليات الحذف غير المصرح بها');
            console.log('   • التعديلات المهمة دون تسجيل');
            console.log('   • عدم توفر نسخ احتياطية حديثة');
            
            console.log('\n📋 الخدمات المضافة:');
            console.log('   1. monitoring_service.js - مراقبة دورية');
            console.log('   2. smart_backup_service.js - نسخ احتياطية ذكية');
            console.log('   3. audit_log - تسجيل جميع العمليات');
            console.log('   4. protection triggers - حماية تلقائية');
            
            console.log('\n🚀 للتشغيل المستمر:');
            console.log('   node monitoring_service.js &');
            console.log('   node smart_backup_service.js &');
            
        } catch (error) {
            console.error('❌ خطأ في تطبيق النظام:', error);
        } finally {
            this.close();
        }
    }

    // مساعدات للاستعلامات
    async runQuery(sql, params = []) {
        return new Promise((resolve, reject) => {
            if (params.length > 0) {
                this.db.run(sql, params, function(err) {
                    if (err) reject(err);
                    else resolve({ id: this.lastID, changes: this.changes });
                });
            } else {
                this.db.all(sql, (err, rows) => {
                    if (err) reject(err);
                    else resolve(rows || []);
                });
            }
        });
    }

    async queryBackup(sql, params = []) {
        return new Promise((resolve, reject) => {
            this.backupDb.all(sql, params, (err, rows) => {
                if (err) reject(err);
                else resolve(rows || []);
            });
        });
    }

    close() {
        if (this.db) this.db.close();
        if (this.backupDb) this.backupDb.close();
    }
}

// تشغيل النظام إذا تم استدعاؤه مباشرة
if (require.main === module) {
    const protectionSystem = new ComprehensiveDataProtectionSystem();
    protectionSystem.implementFullProtection();
}

module.exports = ComprehensiveDataProtectionSystem;