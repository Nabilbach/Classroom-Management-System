/**
 * Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø´Ø§Ù…Ù„ Ø¶Ø¯ ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
 * Comprehensive Data Protection System
 * 
 * ÙŠØ´Ù…Ù„:
 * 1. Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©
 * 2. Ø¥Ø¶Ø§ÙØ© Ø¢Ù„ÙŠØ§Øª Ø§Ù„Ø­Ù…Ø§ÙŠØ© (Triggers)
 * 3. Ù†Ø¸Ø§Ù… Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¯ÙˆØ±ÙŠ
 * 4. Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø°ÙƒÙŠØ©
 */

const sqlite3 = require('sqlite3').verbose();
const fs = require('fs');
const path = require('path');

class ComprehensiveDataProtectionSystem {
    constructor(dbPath = 'classroom.db', backupPath = 'classroom_backup_20250924_174347.db') {
        this.dbPath = dbPath;
        this.backupPath = backupPath;
        this.db = null;
        this.backupDb = null;
    }

    async connect() {
        return new Promise((resolve, reject) => {
            this.db = new sqlite3.Database(this.dbPath, sqlite3.OPEN_READWRITE, (err) => {
                if (err) {
                    reject(err);
                } else {
                    console.log('âœ… Ù…ØªØµÙ„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©');
                    
                    this.backupDb = new sqlite3.Database(this.backupPath, sqlite3.OPEN_READONLY, (err) => {
                        if (err) {
                            console.warn('âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©:', err.message);
                            resolve();
                        } else {
                            console.log('âœ… Ù…ØªØµÙ„ Ø¨Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©');
                            resolve();
                        }
                    });
                }
            });
        });
    }

    // Ø®Ø·ÙˆØ© 1: Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©
    async restoreMissingData() {
        console.log('\nðŸ”§ Ø¨Ø¯Ø¡ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©...');
        
        if (!this.backupDb) {
            console.log('âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù…ØªØ§Ø­Ø© Ù„Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø©');
            return;
        }

        let restoredCount = 0;

        // Ø§Ø³ØªØ¹Ø§Ø¯Ø© TextbookEntry Ø§Ù„Ù…ÙÙ‚ÙˆØ¯
        try {
            console.log('ðŸ“– Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø¯ÙØªØ± Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ù…ÙÙ‚ÙˆØ¯...');
            
            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…ÙÙ‚ÙˆØ¯
            const missingTextbook = await this.queryBackup(`
                SELECT * FROM TextbookEntries 
                WHERE id NOT IN (
                    SELECT id FROM TextbookEntries
                )
                LIMIT 1
            `);

            if (missingTextbook.length > 0) {
                const entry = missingTextbook[0];
                await this.runQuery(`
                    INSERT INTO TextbookEntries (
                        id, date, startTime, duration, sectionId, sectionName,
                        lessonTitle, sessionNumber, completedStages, lessonContent,
                        teacherSignature, notes, isAutoGenerated, originalLessonId,
                        createdAt, updatedAt
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `, Object.values(entry));
                
                console.log(`   âœ… ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø©: ${entry.lessonTitle} - ${entry.date}`);
                restoredCount++;
            }
        } catch (error) {
            console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø¯ÙØªØ± Ø§Ù„Ù†ØµÙˆØµ:', error.message);
        }

        // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ù…ÙÙ‚ÙˆØ¯
        try {
            console.log('ðŸ‘¥ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ù…ÙÙ‚ÙˆØ¯...');
            
            const missingStudent = await this.queryBackup(`
                SELECT * FROM Students 
                ORDER BY id DESC LIMIT 1
            `);

            // ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø·Ø§Ù„Ø¨ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            if (missingStudent.length > 0) {
                const student = missingStudent[0];
                const exists = await this.runQuery(`SELECT id FROM Students WHERE id = ?`, [student.id]);
                
                if (exists.length === 0) {
                    await this.runQuery(`
                        INSERT INTO Students (
                            id, first_name, last_name, pathway_number, birth_date,
                            class_order, gender, section_id, createdAt, updatedAt
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    `, Object.values(student));
                    
                    console.log(`   âœ… ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø©: ${student.first_name} ${student.last_name}`);
                    restoredCount++;
                }
            }
        } catch (error) {
            console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø·Ø§Ù„Ø¨:', error.message);
        }

        console.log(`\nðŸ“Š Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ¹Ø§Ø¯Ø©: ${restoredCount}`);
    }

    // Ø®Ø·ÙˆØ© 2: Ø¥Ø¶Ø§ÙØ© Ø¢Ù„ÙŠØ§Øª Ø§Ù„Ø­Ù…Ø§ÙŠØ© (Database Triggers)
    async addProtectionTriggers() {
        console.log('\nðŸ›¡ï¸ Ø¥Ø¶Ø§ÙØ© Ø¢Ù„ÙŠØ§Øª Ø§Ù„Ø­Ù…Ø§ÙŠØ© (Triggers)...');
        
        const triggers = [
            // Trigger Ù„ØªØ³Ø¬ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø­Ø°Ù
            {
                name: 'audit_deletions',
                sql: `
                CREATE TRIGGER IF NOT EXISTS audit_deletions_textbook
                BEFORE DELETE ON TextbookEntries
                BEGIN
                    INSERT INTO audit_log (
                        table_name, record_id, action_type, old_values, timestamp
                    ) VALUES (
                        'TextbookEntries',
                        OLD.id,
                        'DELETE',
                        json_object(
                            'id', OLD.id,
                            'date', OLD.date,
                            'lessonTitle', OLD.lessonTitle,
                            'sectionId', OLD.sectionId
                        ),
                        datetime('now')
                    );
                END
                `
            },
            
            // Trigger Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø·Ù„Ø§Ø¨ Ù…Ù† Ø§Ù„Ø­Ø°Ù Ø§Ù„Ø¹Ø±Ø¶ÙŠ
            {
                name: 'protect_students',
                sql: `
                CREATE TRIGGER IF NOT EXISTS audit_deletions_students
                BEFORE DELETE ON Students
                BEGIN
                    INSERT INTO audit_log (
                        table_name, record_id, action_type, old_values, timestamp
                    ) VALUES (
                        'Students',
                        OLD.id,
                        'DELETE',
                        json_object(
                            'id', OLD.id,
                            'first_name', OLD.first_name,
                            'last_name', OLD.last_name,
                            'pathway_number', OLD.pathway_number
                        ),
                        datetime('now')
                    );
                END
                `
            },

            // Trigger Ù„Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ø¹Ù†Ø¯ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ø©
            {
                name: 'backup_on_critical_changes',
                sql: `
                CREATE TRIGGER IF NOT EXISTS backup_on_critical_updates
                AFTER UPDATE ON TextbookEntries
                WHEN OLD.lessonContent != NEW.lessonContent OR OLD.date != NEW.date
                BEGIN
                    INSERT INTO audit_log (
                        table_name, record_id, action_type, old_values, new_values, timestamp
                    ) VALUES (
                        'TextbookEntries',
                        NEW.id,
                        'CRITICAL_UPDATE',
                        json_object('lessonContent', OLD.lessonContent, 'date', OLD.date),
                        json_object('lessonContent', NEW.lessonContent, 'date', NEW.date),
                        datetime('now')
                    );
                END
                `
            }
        ];

        // Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ audit_log Ø£ÙˆÙ„Ø§Ù‹
        await this.createAuditLogTable();

        for (const trigger of triggers) {
            try {
                await this.runQuery(trigger.sql);
                console.log(`   âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡: ${trigger.name}`);
            } catch (error) {
                console.error(`   âŒ Ø®Ø·Ø£ ÙÙŠ ${trigger.name}:`, error.message);
            }
        }
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ audit_log
    async createAuditLogTable() {
        const sql = `
        CREATE TABLE IF NOT EXISTS audit_log (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            table_name TEXT NOT NULL,
            record_id TEXT,
            action_type TEXT NOT NULL,
            old_values TEXT,
            new_values TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            user_info TEXT DEFAULT 'system'
        )
        `;
        
        await this.runQuery(sql);
        console.log('   âœ… Ø¬Ø¯ÙˆÙ„ audit_log Ø¬Ø§Ù‡Ø²');
    }

    // Ø®Ø·ÙˆØ© 3: Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¯ÙˆØ±ÙŠ
    async createMonitoringSystem() {
        console.log('\nðŸ“Š Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¯ÙˆØ±ÙŠ...');
        
        const monitoringScript = `
        // Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¯ÙˆØ±ÙŠ - ÙŠØªÙ… ØªØ´ØºÙŠÙ„Ù‡ ÙƒÙ„ Ø³Ø§Ø¹Ø©
        const sqlite3 = require('sqlite3').verbose();
        
        class DataIntegrityMonitor {
            async checkSystemHealth() {
                const db = new sqlite3.Database('classroom.db');
                
                // ÙØ­Øµ Ø§Ù„ØªØ·Ø§Ø¨Ù‚
                const issues = [];
                
                // ÙØ­Øµ ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø¯ÙŠØ«Ø©
                db.all(\`
                    SELECT COUNT(*) as recent_deletions 
                    FROM audit_log 
                    WHERE action_type = 'DELETE' 
                    AND timestamp >= datetime('now', '-1 hour')
                \`, (err, result) => {
                    if (!err && result[0].recent_deletions > 0) {
                        console.warn('âš ï¸ ØªÙ… Ø­Ø°Ù', result[0].recent_deletions, 'Ø³Ø¬Ù„ ÙÙŠ Ø§Ù„Ø³Ø§Ø¹Ø© Ø§Ù„Ù…Ø§Ø¶ÙŠØ©');
                    }
                });
                
                db.close();
            }
        }
        
        // ØªØ´ØºÙŠÙ„ Ø§Ù„ÙØ­Øµ
        setInterval(async () => {
            const monitor = new DataIntegrityMonitor();
            await monitor.checkSystemHealth();
        }, 60 * 60 * 1000); // ÙƒÙ„ Ø³Ø§Ø¹Ø©
        `;
        
        fs.writeFileSync('monitoring_service.js', monitoringScript);
        console.log('   âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©: monitoring_service.js');
    }

    // Ø®Ø·ÙˆØ© 4: Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø°ÙƒÙŠØ©
    async setupSmartBackups() {
        console.log('\nðŸ’¾ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ø°ÙƒÙŠØ©...');
        
        const backupScript = `
        const fs = require('fs');
        const path = require('path');
        
        class SmartBackupSystem {
            createBackup() {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const backupName = \`auto_backup_\${timestamp}.db\`;
                
                try {
                    if (!fs.existsSync('auto_backups')) {
                        fs.mkdirSync('auto_backups');
                    }
                    
                    fs.copyFileSync('classroom.db', path.join('auto_backups', backupName));
                    console.log('âœ… Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ©:', backupName);
                    
                    // Ø­Ø°Ù Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ù€ 10 Ù†Ø³Ø® ÙÙ‚Ø·)
                    this.cleanOldBackups();
                } catch (error) {
                    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©:', error.message);
                }
            }
            
            cleanOldBackups() {
                try {
                    const backupDir = 'auto_backups';
                    const files = fs.readdirSync(backupDir)
                        .filter(file => file.startsWith('auto_backup_'))
                        .map(file => ({
                            name: file,
                            time: fs.statSync(path.join(backupDir, file)).mtime
                        }))
                        .sort((a, b) => b.time - a.time);
                    
                    // Ø­Ø°Ù Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø²Ø§Ø¦Ø¯Ø©
                    files.slice(10).forEach(file => {
                        fs.unlinkSync(path.join(backupDir, file.name));
                        console.log('ðŸ—‘ï¸ Ø­Ø°Ù Ù†Ø³Ø®Ø© Ù‚Ø¯ÙŠÙ…Ø©:', file.name);
                    });
                } catch (error) {
                    console.error('âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©:', error.message);
                }
            }
        }
        
        // Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ÙƒÙ„ 6 Ø³Ø§Ø¹Ø§Øª
        setInterval(() => {
            const backup = new SmartBackupSystem();
            backup.createBackup();
        }, 6 * 60 * 60 * 1000);
        
        // Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ÙÙˆØ±ÙŠØ© Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„
        const initialBackup = new SmartBackupSystem();
        initialBackup.createBackup();
        `;
        
        fs.writeFileSync('smart_backup_service.js', backupScript);
        console.log('   âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: smart_backup_service.js');
    }

    // ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø´Ø§Ù…Ù„
    async implementFullProtection() {
        console.log('ðŸš¨ ØªØ·Ø¨ÙŠÙ‚ Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø´Ø§Ù…Ù„ Ø¶Ø¯ ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
        console.log('='.repeat(80));
        
        try {
            await this.connect();
            
            // Ø®Ø·ÙˆØ© 1: Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©
            await this.restoreMissingData();
            
            // Ø®Ø·ÙˆØ© 2: Ø¥Ø¶Ø§ÙØ© Ø¢Ù„ÙŠØ§Øª Ø§Ù„Ø­Ù…Ø§ÙŠØ©
            await this.addProtectionTriggers();
            
            // Ø®Ø·ÙˆØ© 3: Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©
            await this.createMonitoringSystem();
            
            // Ø®Ø·ÙˆØ© 4: Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ø°ÙƒÙŠØ©
            await this.setupSmartBackups();
            
            console.log('\n' + '='.repeat(80));
            console.log('âœ… ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø´Ø§Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­!');
            console.log('ðŸ›¡ï¸ Ø§Ù„Ù†Ø¸Ø§Ù… Ù…Ø­Ù…ÙŠ Ø§Ù„Ø¢Ù† Ø¶Ø¯:');
            console.log('   â€¢ ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ø±Ø¶ÙŠ');
            console.log('   â€¢ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø­Ø°Ù ØºÙŠØ± Ø§Ù„Ù…ØµØ±Ø­ Ø¨Ù‡Ø§');
            console.log('   â€¢ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ø¯ÙˆÙ† ØªØ³Ø¬ÙŠÙ„');
            console.log('   â€¢ Ø¹Ø¯Ù… ØªÙˆÙØ± Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø­Ø¯ÙŠØ«Ø©');
            
            console.log('\nðŸ“‹ Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…Ø¶Ø§ÙØ©:');
            console.log('   1. monitoring_service.js - Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¯ÙˆØ±ÙŠØ©');
            console.log('   2. smart_backup_service.js - Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø°ÙƒÙŠØ©');
            console.log('   3. audit_log - ØªØ³Ø¬ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª');
            console.log('   4. protection triggers - Ø­Ù…Ø§ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ©');
            
            console.log('\nðŸš€ Ù„Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙ…Ø±:');
            console.log('   node monitoring_service.js &');
            console.log('   node smart_backup_service.js &');
            
        } catch (error) {
            console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù†Ø¸Ø§Ù…:', error);
        } finally {
            this.close();
        }
    }

    // Ù…Ø³Ø§Ø¹Ø¯Ø§Øª Ù„Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª
    async runQuery(sql, params = []) {
        return new Promise((resolve, reject) => {
            if (params.length > 0) {
                this.db.run(sql, params, function(err) {
                    if (err) reject(err);
                    else resolve({ id: this.lastID, changes: this.changes });
                });
            } else {
                this.db.all(sql, (err, rows) => {
                    if (err) reject(err);
                    else resolve(rows || []);
                });
            }
        });
    }

    async queryBackup(sql, params = []) {
        return new Promise((resolve, reject) => {
            this.backupDb.all(sql, params, (err, rows) => {
                if (err) reject(err);
                else resolve(rows || []);
            });
        });
    }

    close() {
        if (this.db) this.db.close();
        if (this.backupDb) this.backupDb.close();
    }
}

// ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¥Ø°Ø§ ØªÙ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡ Ù…Ø¨Ø§Ø´Ø±Ø©
if (require.main === module) {
    const protectionSystem = new ComprehensiveDataProtectionSystem();
    protectionSystem.implementFullProtection();
}

module.exports = ComprehensiveDataProtectionSystem;