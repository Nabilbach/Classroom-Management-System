const sqlite3 = require('sqlite3').verbose();
const fs = require('fs');
const path = require('path');

/**
 * ŸÜÿ∏ÿßŸÖ ŸÖÿ±ÿßŸÇÿ®ÿ© ÿ≥ŸÑÿßŸÖÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≠ÿØÿ´ - ŸÖÿ™ŸàÿßŸÅŸÇ ŸÖÿπ ÿßŸÑÿ®ŸÜŸäÿ© ÿßŸÑÿ≠ŸÇŸäŸÇŸäÿ© ŸÑŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
 * Updated Data Integrity Monitoring System
 */

class UpdatedDataIntegrityMonitor {
    constructor(dbPath = 'classroom.db') {
        this.dbPath = dbPath;
        this.db = null;
        this.reportPath = 'data_integrity_reports';
        
        // ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ™ŸÇÿßÿ±Ÿäÿ± ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØ
        if (!fs.existsSync(this.reportPath)) {
            fs.mkdirSync(this.reportPath, { recursive: true });
        }
    }

    // ŸÅÿ™ÿ≠ ÿßÿ™ÿµÿßŸÑ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    async connect() {
        return new Promise((resolve, reject) => {
            this.db = new sqlite3.Database(this.dbPath, sqlite3.OPEN_READWRITE, (err) => {
                if (err) {
                    console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™:', err);
                    reject(err);
                } else {
                    console.log('‚úÖ ÿ™ŸÖ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™');
                    resolve();
                }
            });
        });
    }

    // ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿßÿ™ÿµÿßŸÑ
    close() {
        if (this.db) {
            this.db.close();
        }
    }

    // ŸÅÿ≠ÿµ ÿ≠ÿßŸÑÿ© TextbookEntries - ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä ŸÑŸÑÿØÿ±Ÿàÿ≥
    async checkTextbookEntriesStatus() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT 
                    date,
                    COUNT(*) as total_entries,
                    COUNT(DISTINCT sectionId) as unique_sections,
                    GROUP_CONCAT(DISTINCT sectionName) as section_names,
                    MIN(startTime) as earliest_time,
                    MAX(startTime) as latest_time
                FROM TextbookEntries
                GROUP BY date
                ORDER BY date DESC
            `;

            this.db.all(query, (err, rows) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(rows);
                }
            });
        });
    }

    // ŸÅÿ≠ÿµ ÿßŸÑÿ™ÿ∑ÿßÿ®ŸÇ ÿ®ŸäŸÜ TextbookEntries ŸàÿßŸÑÿ≠ÿ∂Ÿàÿ±
    async checkTextbookAttendanceConsistency() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT 
                    te.date,
                    te.sectionId,
                    te.sectionName,
                    te.lessonTitle,
                    COUNT(DISTINCT a.studentId) as unique_students_with_attendance,
                    COUNT(a.id) as total_attendance_records,
                    CASE 
                        WHEN COUNT(a.id) = 0 THEN 'NO_ATTENDANCE_RECORDED'
                        WHEN COUNT(DISTINCT a.studentId) < 5 THEN 'LOW_ATTENDANCE'
                        WHEN COUNT(DISTINCT a.studentId) < 15 THEN 'MEDIUM_ATTENDANCE'
                        ELSE 'GOOD_ATTENDANCE'
                    END as attendance_status
                FROM TextbookEntries te
                LEFT JOIN Attendances a ON te.date = a.date AND te.sectionId = a.sectionId
                GROUP BY te.date, te.sectionId, te.sectionName, te.lessonTitle
                ORDER BY te.date DESC, te.sectionName
            `;

            this.db.all(query, (err, rows) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(rows);
                }
            });
        });
    }

    // ŸÅÿ≠ÿµ ÿ≥ÿ¨ŸÑÿßÿ™ ÿßŸÑÿ≠ÿ∂Ÿàÿ± ÿßŸÑÿ£Ÿäÿ™ÿßŸÖ (ÿ®ÿØŸàŸÜ ÿØÿ±Ÿàÿ≥ ŸÖÿ∑ÿßÿ®ŸÇÿ©)
    async checkOrphanedAttendances() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT 
                    a.date,
                    a.sectionId,
                    COUNT(*) as attendance_count,
                    GROUP_CONCAT(DISTINCT s.name) as section_name
                FROM Attendances a
                LEFT JOIN TextbookEntries te ON a.date = te.date AND a.sectionId = te.sectionId
                LEFT JOIN Sections s ON a.sectionId = s.id
                WHERE te.id IS NULL
                GROUP BY a.date, a.sectionId
                ORDER BY a.date DESC
            `;

            this.db.all(query, (err, rows) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(rows);
                }
            });
        });
    }

    // ŸÅÿ≠ÿµ ŸÅÿ¨Ÿàÿßÿ™ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ ŸÅŸä ÿØŸÅÿ™ÿ± ÿßŸÑŸÜÿµŸàÿµ
    async checkDateGapsInTextbook() {
        return new Promise((resolve, reject) => {
            // ÿ£ŸàŸÑÿßŸã ŸÜÿ≠ÿµŸÑ ÿπŸÑŸâ ŸÜÿ∑ÿßŸÇ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ
            this.db.get(`SELECT MIN(date) as min_date, MAX(date) as max_date FROM TextbookEntries`, (err, range) => {
                if (err || !range) {
                    reject(err || new Error('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÅŸä TextbookEntries'));
                    return;
                }

                const query = `
                    WITH RECURSIVE date_range(check_date) AS (
                        SELECT date('${range.min_date}') as check_date
                        UNION ALL
                        SELECT date(check_date, '+1 day')
                        FROM date_range
                        WHERE check_date < date('${range.max_date}')
                    )
                    SELECT 
                        dr.check_date as missing_date,
                        strftime('%w', dr.check_date) as day_of_week,
                        CASE 
                            WHEN strftime('%w', dr.check_date) IN ('0', '6') THEN 'WEEKEND'
                            ELSE 'POTENTIAL_MISSING_LESSON'
                        END as gap_type
                    FROM date_range dr
                    LEFT JOIN TextbookEntries te ON dr.check_date = te.date
                    WHERE te.date IS NULL
                    AND strftime('%w', dr.check_date) NOT IN ('0', '6')
                    ORDER BY dr.check_date
                `;

                this.db.all(query, (err, rows) => {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(rows);
                    }
                });
            });
        });
    }

    // ŸÅÿ≠ÿµ ÿ¨ŸàÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÅŸä TextbookEntries
    async checkDataQuality() {
        return new Promise((resolve, reject) => {
            const qualityChecks = {
                emptyContent: `
                    SELECT COUNT(*) as count FROM TextbookEntries 
                    WHERE lessonContent IS NULL OR lessonContent = '' OR length(lessonContent) < 10
                `,
                missingTitles: `
                    SELECT COUNT(*) as count FROM TextbookEntries 
                    WHERE lessonTitle IS NULL OR lessonTitle = ''
                `,
                invalidDurations: `
                    SELECT COUNT(*) as count FROM TextbookEntries 
                    WHERE duration IS NULL OR duration <= 0 OR duration > 8
                `,
                futureDates: `
                    SELECT COUNT(*) as count FROM TextbookEntries 
                    WHERE date > date('now', '+1 day')
                `,
                duplicateEntries: `
                    SELECT date, sectionId, COUNT(*) as duplicates
                    FROM TextbookEntries 
                    GROUP BY date, sectionId, startTime
                    HAVING COUNT(*) > 1
                `
            };

            const results = {};
            let completed = 0;
            const total = Object.keys(qualityChecks).length;

            Object.entries(qualityChecks).forEach(([key, query]) => {
                if (key === 'duplicateEntries') {
                    this.db.all(query, (err, rows) => {
                        if (err) {
                            reject(err);
                            return;
                        }
                        results[key] = rows;
                        completed++;
                        if (completed === total) resolve(results);
                    });
                } else {
                    this.db.get(query, (err, result) => {
                        if (err) {
                            reject(err);
                            return;
                        }
                        results[key] = result?.count || 0;
                        completed++;
                        if (completed === total) resolve(results);
                    });
                }
            });
        });
    }

    // ÿ™ÿ¥ÿ∫ŸäŸÑ ŸÅÿ≠ÿµ ÿ¥ÿßŸÖŸÑ ŸÖÿ≠ÿØÿ´
    async runComprehensiveCheck() {
        console.log('üîç ÿ®ÿØÿ° ÿßŸÑŸÅÿ≠ÿµ ÿßŸÑÿ¥ÿßŸÖŸÑ ÿßŸÑŸÖÿ≠ÿØÿ´ ŸÑÿ≥ŸÑÿßŸÖÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™...\n');
        
        const report = {
            timestamp: new Date().toISOString(),
            checks: {},
            summary: {
                totalIssues: 0,
                criticalIssues: 0,
                warnings: 0,
                status: 'UNKNOWN'
            }
        };

        try {
            await this.connect();

            // 1. ŸÅÿ≠ÿµ ÿ≠ÿßŸÑÿ© ÿØŸÅÿ™ÿ± ÿßŸÑŸÜÿµŸàÿµ
            console.log('üìñ ŸÅÿ≠ÿµ ÿ≠ÿßŸÑÿ© ÿØŸÅÿ™ÿ± ÿßŸÑŸÜÿµŸàÿµ...');
            const textbookStatus = await this.checkTextbookEntriesStatus();
            report.checks.textbookStatus = textbookStatus;

            // 2. ŸÅÿ≠ÿµ ÿßŸÑÿ™ÿ∑ÿßÿ®ŸÇ ŸÖÿπ ÿßŸÑÿ≠ÿ∂Ÿàÿ±
            console.log('üë• ŸÅÿ≠ÿµ ÿßŸÑÿ™ÿ∑ÿßÿ®ŸÇ ŸÖÿπ ÿ≥ÿ¨ŸÑÿßÿ™ ÿßŸÑÿ≠ÿ∂Ÿàÿ±...');
            const attendanceConsistency = await this.checkTextbookAttendanceConsistency();
            report.checks.attendanceConsistency = {
                details: attendanceConsistency,
                noAttendance: attendanceConsistency.filter(row => row.attendance_status === 'NO_ATTENDANCE_RECORDED').length,
                lowAttendance: attendanceConsistency.filter(row => row.attendance_status === 'LOW_ATTENDANCE').length
            };

            // 3. ŸÅÿ≠ÿµ ÿ≥ÿ¨ŸÑÿßÿ™ ÿßŸÑÿ≠ÿ∂Ÿàÿ± ÿßŸÑÿ£Ÿäÿ™ÿßŸÖ
            console.log('üîç ŸÅÿ≠ÿµ ÿ≥ÿ¨ŸÑÿßÿ™ ÿßŸÑÿ≠ÿ∂Ÿàÿ± ÿßŸÑÿ£Ÿäÿ™ÿßŸÖ...');
            const orphanedAttendances = await this.checkOrphanedAttendances();
            report.checks.orphanedAttendances = orphanedAttendances;

            // 4. ŸÅÿ≠ÿµ ŸÅÿ¨Ÿàÿßÿ™ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ
            console.log('üìÖ ŸÅÿ≠ÿµ ŸÅÿ¨Ÿàÿßÿ™ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ...');
            try {
                const dateGaps = await this.checkDateGapsInTextbook();
                report.checks.dateGaps = dateGaps;
            } catch (error) {
                console.warn('‚ö†Ô∏è ÿ™ÿπÿ∞ÿ± ŸÅÿ≠ÿµ ŸÅÿ¨Ÿàÿßÿ™ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ:', error.message);
                report.checks.dateGaps = [];
            }

            // 5. ŸÅÿ≠ÿµ ÿ¨ŸàÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
            console.log('üîß ŸÅÿ≠ÿµ ÿ¨ŸàÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™...');
            const dataQuality = await this.checkDataQuality();
            report.checks.dataQuality = dataQuality;

            // ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖŸÑÿÆÿµ
            report.summary.criticalIssues = 
                report.checks.orphanedAttendances.length +
                (dataQuality.duplicateEntries?.length || 0);

            report.summary.warnings = 
                report.checks.attendanceConsistency.noAttendance +
                report.checks.attendanceConsistency.lowAttendance +
                (report.checks.dateGaps?.length || 0) +
                dataQuality.emptyContent +
                dataQuality.missingTitles;

            report.summary.totalIssues = report.summary.criticalIssues + report.summary.warnings;

            // ÿ™ÿ≠ÿØŸäÿØ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿπÿßŸÖÿ©
            if (report.summary.criticalIssues > 0) {
                report.summary.status = 'CRITICAL';
            } else if (report.summary.warnings > 5) {
                report.summary.status = 'WARNING';
            } else if (report.summary.warnings > 0) {
                report.summary.status = 'MINOR_ISSUES';
            } else {
                report.summary.status = 'HEALTHY';
            }

            // ÿ∑ÿ®ÿßÿπÿ© ÿßŸÑÿ™ŸÇÿ±Ÿäÿ±
            this.printUpdatedReport(report);
            
            // ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ±
            await this.saveReport(report);

            return report;

        } catch (error) {
            console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÅÿ≠ÿµ ÿßŸÑÿ¥ÿßŸÖŸÑ:', error);
            throw error;
        } finally {
            this.close();
        }
    }

    // ÿ∑ÿ®ÿßÿπÿ© ÿßŸÑÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑŸÖÿ≠ÿØÿ´
    printUpdatedReport(report) {
        console.log('\n' + '='.repeat(80));
        console.log('üìä ÿ™ŸÇÿ±Ÿäÿ± ÿ≥ŸÑÿßŸÖÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≠ÿØÿ´');
        console.log('='.repeat(80));
        
        // ÿ≠ÿßŸÑÿ© ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿπÿßŸÖÿ©
        const statusEmoji = {
            'HEALTHY': '‚úÖ',
            'MINOR_ISSUES': 'üîµ',
            'WARNING': '‚ö†Ô∏è',
            'CRITICAL': 'üö®'
        };
        
        console.log(`\n${statusEmoji[report.summary.status]} ÿ≠ÿßŸÑÿ© ÿßŸÑŸÜÿ∏ÿßŸÖ: ${report.summary.status}`);
        console.log(`üìä ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÖÿ¥ÿßŸÉŸÑ: ${report.summary.totalIssues}`);
        console.log(`üö® ÿßŸÑŸÖÿ¥ÿßŸÉŸÑ ÿßŸÑÿ≠ÿ±ÿ¨ÿ©: ${report.summary.criticalIssues}`);
        console.log(`‚ö†Ô∏è ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™: ${report.summary.warnings}`);

        // ÿ™ŸÅÿßÿµŸäŸÑ ÿØŸÅÿ™ÿ± ÿßŸÑŸÜÿµŸàÿµ
        console.log('\nüìñ ÿ≠ÿßŸÑÿ© ÿØŸÅÿ™ÿ± ÿßŸÑŸÜÿµŸàÿµ:');
        if (report.checks.textbookStatus.length > 0) {
            console.log(`   üìÖ ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ£ŸäÿßŸÖ ÿßŸÑŸÖÿ≥ÿ¨ŸÑÿ©: ${report.checks.textbookStatus.length}`);
            console.log(`   üìö ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿØÿ±Ÿàÿ≥: ${report.checks.textbookStatus.reduce((sum, day) => sum + day.total_entries, 0)}`);
            
            console.log('\n   ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ£ŸäÿßŸÖ ÿßŸÑÿ£ÿÆŸäÿ±ÿ©:');
            report.checks.textbookStatus.slice(0, 5).forEach((day, index) => {
                console.log(`      ${index + 1}. ${day.date}: ${day.total_entries} ÿØÿ±ÿ≥ÿå ${day.unique_sections} ŸÇÿ≥ŸÖ`);
            });
        } else {
            console.log('   ‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿØÿ±Ÿàÿ≥ ŸÖÿ≥ÿ¨ŸÑÿ© ŸÅŸä ÿØŸÅÿ™ÿ± ÿßŸÑŸÜÿµŸàÿµ!');
        }

        // ŸÖÿ¥ÿßŸÉŸÑ ÿßŸÑÿ≠ÿ∂Ÿàÿ±
        if (report.checks.attendanceConsistency.noAttendance > 0) {
            console.log(`\nüë• ÿØÿ±Ÿàÿ≥ ÿ®ÿØŸàŸÜ ÿ≠ÿ∂Ÿàÿ±: ${report.checks.attendanceConsistency.noAttendance}`);
        }
        if (report.checks.attendanceConsistency.lowAttendance > 0) {
            console.log(`‚ö†Ô∏è ÿØÿ±Ÿàÿ≥ ÿ®ÿ≠ÿ∂Ÿàÿ± ŸÖŸÜÿÆŸÅÿ∂: ${report.checks.attendanceConsistency.lowAttendance}`);
        }

        // ÿßŸÑÿ≥ÿ¨ŸÑÿßÿ™ ÿßŸÑÿ£Ÿäÿ™ÿßŸÖ
        if (report.checks.orphanedAttendances.length > 0) {
            console.log(`\nüîç ÿ≥ÿ¨ŸÑÿßÿ™ ÿ≠ÿ∂Ÿàÿ± Ÿäÿ™ŸäŸÖÿ©: ${report.checks.orphanedAttendances.length}`);
            report.checks.orphanedAttendances.slice(0, 3).forEach((orphan, index) => {
                console.log(`   ${index + 1}. ${orphan.date} - ${orphan.section_name}: ${orphan.attendance_count} ÿ≥ÿ¨ŸÑ`);
            });
        }

        // ŸÅÿ¨Ÿàÿßÿ™ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ
        if (report.checks.dateGaps && report.checks.dateGaps.length > 0) {
            console.log(`\nüìÖ ÿ™Ÿàÿßÿ±ŸäÿÆ ŸÖŸÅŸÇŸàÿØÿ© ŸÖÿ≠ÿ™ŸÖŸÑÿ©: ${report.checks.dateGaps.length}`);
            if (report.checks.dateGaps.length <= 5) {
                report.checks.dateGaps.forEach((gap, index) => {
                    console.log(`   ${index + 1}. ${gap.missing_date}`);
                });
            } else {
                console.log(`   ŸÖŸÜ ${report.checks.dateGaps[0].missing_date} ÿ•ŸÑŸâ ${report.checks.dateGaps[report.checks.dateGaps.length - 1].missing_date}`);
            }
        }

        // ÿ¨ŸàÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
        const quality = report.checks.dataQuality;
        if (quality.emptyContent > 0 || quality.missingTitles > 0) {
            console.log('\nüîß ŸÖÿ¥ÿßŸÉŸÑ ÿ¨ŸàÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™:');
            if (quality.emptyContent > 0) console.log(`   üìù ŸÖÿ≠ÿ™ŸàŸâ ŸÅÿßÿ±ÿ∫: ${quality.emptyContent}`);
            if (quality.missingTitles > 0) console.log(`   üìå ÿπŸÜÿßŸàŸäŸÜ ŸÖŸÅŸÇŸàÿØÿ©: ${quality.missingTitles}`);
            if (quality.invalidDurations > 0) console.log(`   ‚è±Ô∏è ŸÖÿØÿØ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©: ${quality.invalidDurations}`);
            if (quality.futureDates > 0) console.log(`   üìÖ ÿ™Ÿàÿßÿ±ŸäÿÆ ŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸäÿ©: ${quality.futureDates}`);
        }

        console.log('\n' + '='.repeat(80));
    }

    // ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ± ŸÅŸä ŸÖŸÑŸÅ
    async saveReport(report) {
        const filename = `updated_integrity_report_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        const filepath = path.join(this.reportPath, filename);
        
        try {
            fs.writeFileSync(filepath, JSON.stringify(report, null, 2));
            console.log(`üíæ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ± ŸÅŸä: ${filepath}`);
        } catch (error) {
            console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ±:', error);
        }
    }
}

// ÿ•ÿ∞ÿß ÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑŸÖŸÑŸÅ ŸÖÿ®ÿßÿ¥ÿ±ÿ©
if (require.main === module) {
    const monitor = new UpdatedDataIntegrityMonitor();
    
    // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑŸÅÿ≠ÿµ ÿßŸÑÿ¥ÿßŸÖŸÑ
    monitor.runComprehensiveCheck()
        .catch(console.error);
}

module.exports = UpdatedDataIntegrityMonitor;